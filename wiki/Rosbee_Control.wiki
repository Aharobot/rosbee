#summary the setup and thought process behind the move_platform node

= Introduction =
on this page we will try to explain the setup of the rosbee_control package and the move_platform node.
the rosbee_control package contains the main launch files for the rosbee project. this includes the launch file for the robot and launch files for mapping and navigating on an existing map. it also contains the move_platform node, which is the node which provides the interface to the platform, allowing it to be controlled with cmd_vel messages and publishing encoder values for the odometry node.

= Launch files =
the rosbee_control package contains the following launch files:
  * rosbee.launch
  * pc_launch.launch
  * mapping_launch.launch

=== rosbee.launch === 
rosbee.launch is the launch file to bring up the robot. the launch file starts the following nodes: odometry, move_platform and the kinect or laser.
the line for the laser is: 
{{{
<node name="hokuyo_node" pkg="hokuyo_node" type="hokuyo_node" />
}}}
the line for the kinect is:
{{{
<include file="$(find pointcloud_to_laserscan)/launch/kinext_laser_2.launch" />
}}}

to select the kinect or laser you will need to uncomment there lines. both the laser and kinect can be used at the same time.

===pc_launch.launch===
pc_launch.launch runs everything from the navigation stack. but only works if you have a map of the area. (as it doesnt start the gmapping node).
this launch file want to get the location of the map of the area you are going to drive in. to specify the location for the map you will need to start the launch file in the following way: 
{{{
roslaunch rosbee_control pc_launch.launch map:=<location of your map>
}}}
when no map(yaml) file is specified it will start the navigation stack with a map of the mechatronica lab(not recommended)

===mapping_launch.launch===
mapping_launch.launch is the launch file that we normally use for testing. it will start everything that is needed to make a map(except the robot it self) and a teleop keyboard, which allows you to send commands to the robot with the qwe and s keys.

when you run this launch file you will notice rviz starting. when you see the costmap being shown in rviz everything is done starting.

=move_platform=

the move_platform node allows us to control the platform with ros messages. it listens on the topic "/cmd_vel" (the default ros topic for move commands) and publishes encoder values on the "/enc" topic.

===communicating with the platform===
to communicate with the platform we use a serial connection. on this serial connection we send PWM values that the platform has to use. after every send of PWM values the platform responds with its current encoder values.
for communication with the platform we use the following protocol. 
{{{
$(leftpwm);(rightpwm)#
}}}
where (leftpwm) is the pwm value for the left wheel and (rightpwm) is the pwm value for the right wheel

the platform answers the with the encoder values according to the following protocol.
{{{
$(leftencoder);(rightencoder)#
}}}
again (leftencoder) is the encoder value of the left wheel, (rightencoder) is the value of the right wheel.

===move_platform.cpp===
move_platform.cpp is the main file of the move_platform nodes. it sets up the services and the subscriber to cmd_vel.
the while loop in move_platform.cpp also makes sure that the platform is updated at at least 5 hertz. it does so by checking if it has been more than 200ms since the last receive, if so it sends a 0 value to the platform making it stop.

===the platform class===
the platform class implements the communication with the platform.
because we had a couple of revisions in the platform we have a couple of different version of the platform class, they all use the same functions but the implementation is different and some functions might not be supported.
the following versions of the Platform class exist:
 * xbee Platform: can be found in the xbeeplatform tag
 * wired Platform: last update was on r99.
 * revised wired Platform: on the laptop to be added

====xbee Platform====
the xbee platform was the first version of the platform. it communicated with the laptop over xbee. the xbee was cause for a lot of instability thats why this version included a restriction on command speed (5 hz max (platform could handle 8 but we wanted to be on the save side)) it also had a thread dedicated to reading the messages from the platform to prevent messages being lost (if a message wasnt read right away it was lost as the xbee connection didnt seem to be buffered).

====wired Platform====
after a while we replaced the xbee connection(between the robot and the laptop) with an serial connection. this gave us a more stable connection. unfortunately the speed of the platform didnt improve. at this version of the platform we were still communicating at 5-8 hertz

====revised wired platform====
this is the final verion of the platform. for this version we have rewritten the software of the platform it self, and introduced a greatly reduced version of the communication protocol. this version of the platform responds at an high speed and makes it possible to work at over 50 hertz. 
this version of the platform also contains the least functionalities, it only allows you to set the speed with which the platform should move.
to make sure the published encoder values stay up to date the node will, when it hasnt send a command to the platform for 200ms, resend the previous command. the node also have a build in timeout in waiting for a reply, to make sure package loss wont crash the node, locking it in its read cycles. 